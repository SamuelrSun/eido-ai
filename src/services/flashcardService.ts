// src/services/flashcardService.ts
import { supabase } from "@/integrations/supabase/client";
import { Deck, Flashcard, FlashcardContent, GenerateDeckParams } from "@/types/flashcard";
import { classOpenAIConfigService } from "./classOpenAIConfig";
import type { User } from "@supabase/supabase-js";

// Define types for Supabase table rows to avoid 'any'
// These should ideally align with your auto-generated Supabase types if you have them fully set up
type FlashcardDeckDBRow = {
  flashcard_deck_id: string; // Primary Key for 'flashcard-decks'
  title: string;
  description: string;
  color: string;
  card_count: number;
  due_cards: number;
  new_cards: number;
  created_at: string; // Timestamptz from DB
  updated_at: string; // Timestamptz from DB
  user_id: string | null;
  class_id: string | null; // Foreign Key to 'classes' table
};

type FlashcardDBRow = {
  flashcard_id: string; // Primary Key for 'flashcards'
  flashcard_deck_id: string; // Foreign Key to 'flashcard-decks'
  front: string;
  back: string;
  difficulty: string;
  next_review: string; // Timestamptz from DB
  last_reviewed: string | null; // Timestamptz from DB
  review_count: number | null;
  created_at: string; // Timestamptz from DB
  updated_at: string; // Timestamptz from DB
  user_id: string | null;
  class_id: string | null; // Foreign Key to 'classes' table
};


/**
 * Service to handle flashcard-related operations
 */
export const flashcardService = {
  /**
   * Generate a deck of flashcards using OpenAI and the vector database
   */
  generateDeck: async (params: GenerateDeckParams): Promise<FlashcardContent[]> => {
    console.log("flashcardService: Attempting to generate flashcards with params:", params);
    
    try {
      // Get class-specific OpenAI configuration (assistantId, vectorStoreId)
      const classConfig = await classOpenAIConfigService.getActiveClassConfig();
      console.log("flashcardService: Active class config for flashcard generation:", JSON.stringify(classConfig, null, 2));
      
      // Invoke the Supabase Edge Function.
      // The Edge Function itself is responsible for using its own OPENAI_API_KEY from environment variables.
      // We pass the classConfig (which contains assistantId and vectorStoreId) to the Edge Function.
      const { data, error } = await supabase.functions.invoke('generate-flashcards', {
        body: {
          title: params.title,
          cardCount: params.cardCount,
          openAIConfig: classConfig // Pass the class-specific assistantId and vectorStoreId
        }
      });

      if (error) {
        console.error("flashcardService: Error calling 'generate-flashcards' Edge Function:", error);
        throw new Error(`Failed to generate flashcards: ${error.message}`);
      }

      if (!data || !data.flashcards || !Array.isArray(data.flashcards)) {
        console.error("flashcardService: Invalid or missing flashcards array in Edge Function response:", data);
        throw new Error("No flashcards were generated or response format was invalid. Please try again.");
      }
      
      console.log(`flashcardService: Received ${data.flashcards.length} flashcards from the Edge Function.`);
      return data.flashcards as FlashcardContent[]; // Assume Edge Function returns FlashcardContent[]
    } catch (error: unknown) { // Changed 'any' to 'unknown' for better type safety
      console.error("flashcardService: Error in generateDeck:", error);
      if (error instanceof Error) { // Type guard
        if (error.message?.includes("Failed to send a request") || 
            error.message?.includes("Failed to fetch")) {
          throw new Error("Unable to connect to the flashcard generation service. Please check your internet connection and try again.");
        }
      }
      throw error; // Re-throw the original error or a new one
    }
  },

  /**
   * Save a new deck to the database
   * The Deck type now includes createdAt and updatedAt, so Omit needs to reflect that.
   * id is auto-generated by the DB.
   */
  saveDeck: async (deck: Omit<Deck, 'id' | 'createdAt' | 'updatedAt'>): Promise<Deck> => {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) throw new Error("User must be logged in to save a deck.");

    const activeClassDataString = sessionStorage.getItem('activeClass');
    let classIdToSave: string | null = null;
    if (activeClassDataString) {
        try {
            const parsedClass = JSON.parse(activeClassDataString);
            classIdToSave = parsedClass.class_id || null; 
        } catch (e) {
            console.error("Error parsing activeClass from session storage in saveDeck", e);
        }
    }

    // Payload for inserting into the 'flashcard-decks' table
    const dbDeckPayload = {
      title: deck.title,
      description: deck.description,
      color: deck.color,
      card_count: deck.cardCount,
      due_cards: deck.dueCards,
      new_cards: deck.newCards,
      user_id: user.id,
      class_id: classIdToSave, 
      // created_at and updated_at will be set by the database (DEFAULT now())
    };

    const { data, error } = await supabase
      .from('flashcard-decks')
      .insert(dbDeckPayload)
      .select()
      .single<FlashcardDeckDBRow>();

    if (error) {
      console.error("Error saving deck:", error);
      throw new Error(`Failed to save deck: ${error.message}`);
    }
    if (!data) {
      throw new Error("Failed to save deck: No data returned from database.");
    }

    // Map the DB row to the application's Deck type
    return {
      id: data.flashcard_deck_id,
      title: data.title,
      description: data.description,
      color: data.color,
      cardCount: data.card_count,
      dueCards: data.due_cards,
      newCards: data.new_cards,
      createdAt: new Date(data.created_at), // Convert string to Date
      updatedAt: new Date(data.updated_at), // Convert string to Date
      userId: data.user_id,
      classId: data.class_id
    };
  },

  /**
   * Save flashcards to the database for a deck
   */
  saveFlashcards: async (deckId: string, flashcards: FlashcardContent[]): Promise<void> => {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) throw new Error("User must be logged in to save flashcards.");
    
    const activeClassDataString = sessionStorage.getItem('activeClass');
    let classIdToSave: string | null = null;
    if (activeClassDataString) {
        try {
            const parsedClass = JSON.parse(activeClassDataString);
            classIdToSave = parsedClass.class_id || null;
        } catch (e) {
            console.error("Error parsing activeClass from session storage in saveFlashcards", e);
        }
    }

    // Payload for inserting into the 'flashcards' table
    const flashcardsToInsert = flashcards.map(card => ({
      flashcard_deck_id: deckId,
      front: card.front,
      back: card.back,
      difficulty: 'medium', 
      next_review: new Date().toISOString(), // DB expects ISO string
      review_count: 0,
      user_id: user.id,
      class_id: classIdToSave,
      // created_at and updated_at will be set by the database
    }));

    const { error } = await supabase
      .from('flashcards')
      .insert(flashcardsToInsert);

    if (error) {
      console.error("Error saving flashcards:", error);
      throw new Error(`Failed to save flashcards: ${error.message}`);
    }
  },

  /**
   * Fetch all decks from the database for the current active class
   */
  fetchDecks: async (): Promise<Deck[]> => {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return [];

    const activeClassDataString = sessionStorage.getItem('activeClass');
    if (!activeClassDataString) {
        console.log("fetchDecks: No active class in session storage.");
        return [];
    }
    let activeClassId: string | null = null;
    try {
        const parsedClass = JSON.parse(activeClassDataString);
        activeClassId = parsedClass.class_id || null;
    } catch(e) {
        console.error("fetchDecks: Error parsing activeClass from session storage", e);
        return [];
    }

    if (!activeClassId) {
        console.log("fetchDecks: No active class_id found.");
        return [];
    }
    
    const { data, error } = await supabase
      .from('flashcard-decks')
      .select('*')
      .eq('user_id', user.id)
      .eq('class_id', activeClassId)
      .order('updated_at', { ascending: false });

    if (error) {
      console.error("Error fetching decks:", error);
      throw new Error(`Failed to fetch decks: ${error.message}`);
    }

    return (data || []).map((deck: FlashcardDeckDBRow): Deck => ({ // Explicit return type for map
      id: deck.flashcard_deck_id,
      title: deck.title,
      description: deck.description,
      color: deck.color,
      cardCount: deck.card_count,
      dueCards: deck.due_cards,
      newCards: deck.new_cards,
      createdAt: new Date(deck.created_at),
      updatedAt: new Date(deck.updated_at),
      userId: deck.user_id,
      classId: deck.class_id
    }));
  },
  
  /**
   * Fetch flashcards for a specific deck
   */
  fetchFlashcards: async (deckId: string): Promise<Flashcard[]> => {
    const { data, error } = await supabase
      .from('flashcards')
      .select('*')
      .eq('flashcard_deck_id', deckId)
      .order('created_at', { ascending: true });
      
    if (error) {
      console.error("Error fetching flashcards:", error);
      throw new Error(`Failed to fetch flashcards: ${error.message}`);
    }
    
    return (data || []).map((card: FlashcardDBRow): Flashcard => ({ // Explicit return type for map
      id: card.flashcard_id,
      deckId: card.flashcard_deck_id,
      front: card.front,
      back: card.back,
      difficulty: card.difficulty,
      nextReview: new Date(card.next_review),
      lastReviewed: card.last_reviewed ? new Date(card.last_reviewed) : null,
      reviewCount: card.review_count,
      createdAt: new Date(card.created_at),
      updatedAt: new Date(card.updated_at),
      userId: card.user_id,
      classId: card.class_id,
    }));
  },
  
  /**
   * Delete a deck and its associated flashcards
   */
  deleteDeck: async (deckId: string): Promise<void> => {
    try {
      // First delete all flashcards associated with this deck
      const { error: flashcardsError } = await supabase
        .from('flashcards')
        .delete()
        .eq('flashcard_deck_id', deckId);
      
      if (flashcardsError) {
        console.error("Error deleting flashcards:", flashcardsError);
        throw new Error(`Failed to delete flashcards: ${flashcardsError.message}`);
      }
      
      // Then delete the deck itself
      const { error: deckError } = await supabase
        .from('flashcard-decks')
        .delete()
        .eq('flashcard_deck_id', deckId);
      
      if (deckError) {
        console.error("Error deleting deck:", deckError);
        throw new Error(`Failed to delete deck: ${deckError.message}`);
      }
      
      console.log(`Successfully deleted deck ${deckId} and its flashcards`);
    } catch (error: unknown) { // Changed 'any' to 'unknown'
      console.error("Error in deleteDeck:", error);
      if (error instanceof Error) { // Type guard
        throw error;
      }
      throw new Error("An unknown error occurred during deck deletion.");
    }
  }
};