// src/services/chatMessageService.ts
import { supabase } from "@/integrations/supabase/client";
import type { User } from "@supabase/supabase-js";
import type { CustomDatabase } from "@/integrations/supabase/client";

// Type for a chat message as it's stored/retrieved from the DB
// Ensure this matches your 'chat_messages' table from types.ts
export type ChatMessageDBRow = CustomDatabase['public']['Tables']['chat_messages']['Row'];

// Type for inserting a new chat message
// Ensure this includes 'conversation_id' and other necessary fields from your DB schema
// 'conversation_id' should be part of ChatMessageDBRow if your types.ts is up-to-date.
// If not, you might need to explicitly add it here:
// export type ChatMessageDBInsert = Omit<ChatMessageDBRow, 'id' | 'created_at' | 'user_id'> & {
//   user_id?: string;
//   conversation_id: string; // Explicitly add if not in ChatMessageDBRow from types
// };
// Assuming conversation_id is in ChatMessageDBRow:
export type ChatMessageDBInsert = CustomDatabase['public']['Tables']['chat_messages']['Insert'];


// Type for a chat message as used in the application
export interface ChatMessageApp {
  id: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  createdAt: Date;
  conversation_id?: string; 
}

const mapToAppMessage = (dbRow: ChatMessageDBRow): ChatMessageApp => ({
  id: dbRow.id,
  role: dbRow.role as 'user' | 'assistant' | 'system', 
  content: dbRow.content,
  createdAt: new Date(dbRow.created_at),
  conversation_id: dbRow.conversation_id || undefined, 
});

export const chatMessageService = {
  /**
   * Saves a chat message to the database.
   * Requires conversation_id in the payload.
   */
  saveMessage: async (
    // The payload should match ChatMessageDBInsert, excluding user_id which is added by the service
    // And ensuring conversation_id is provided.
    messagePayload: Omit<ChatMessageDBInsert, 'user_id' | 'id' | 'created_at'> & { conversation_id: string }
  ): Promise<ChatMessageApp | null> => {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) {
      console.error("chatMessageService.saveMessage: User not authenticated.");
      throw new Error("User must be authenticated to save messages.");
    }

    // Ensure conversation_id is explicitly part of the payload passed to this function
    if (!messagePayload.conversation_id) {
        console.error("chatMessageService.saveMessage: conversation_id is required in the payload.");
        throw new Error("conversation_id is required to save a message.");
    }

    const messageToSave: ChatMessageDBInsert = {
      ...messagePayload,
      user_id: user.id, // Set user_id from the authenticated user
      // created_at will be set by the database default
      // id will be generated by the database
    };

    console.log("[chatMessageService.saveMessage] Saving message:", JSON.stringify(messageToSave, null, 2));

    const { data, error } = await supabase
      .from('chat_messages')
      .insert(messageToSave as any) // Cast to any if ChatMessageDBInsert has optional id/created_at
      .select()
      .single();

    if (error) {
      console.error("chatMessageService.saveMessage: Error saving message:", error);
      throw error;
    }
    if (!data) {
        console.error("chatMessageService.saveMessage: No data returned after insert.");
        return null;
    }
    console.log("[chatMessageService.saveMessage] Message saved successfully:", data);
    return mapToAppMessage(data as ChatMessageDBRow);
  },

  /**
   * Fetches chat messages for a specific conversation.
   */
  fetchMessagesByConversation: async (
    conversationId: string,
    limit: number = 50,
    beforeTimestamp?: string // ISO string for pagination
  ): Promise<ChatMessageApp[]> => {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) {
      console.warn("chatMessageService.fetchMessagesByConversation: User not authenticated.");
      return [];
    }
    if (!conversationId) {
        console.warn("chatMessageService.fetchMessagesByConversation: conversationId is required.");
        return [];
    }
    
    console.log(`[chatMessageService.fetchMessagesByConversation] Fetching messages for conversation: ${conversationId}, limit: ${limit}, before: ${beforeTimestamp || 'N/A'}`);

    let query = supabase
      .from('chat_messages')
      .select('*')
      .eq('user_id', user.id) 
      .eq('conversation_id', conversationId) 
      .order('created_at', { ascending: false }) 
      .limit(limit);

    if (beforeTimestamp) {
      query = query.lt('created_at', beforeTimestamp);
    }

    const { data, error } = await query;

    if (error) {
      console.error("chatMessageService.fetchMessagesByConversation: Error fetching messages:", error);
      throw error;
    }

    const appMessages: ChatMessageApp[] = (data || []).map(mapToAppMessage);
    console.log(`[chatMessageService.fetchMessagesByConversation] Fetched ${appMessages.length} messages.`);
    return appMessages.reverse(); 
  },

  /**
   * Original fetchMessages.
   */
  fetchMessages: async (
    classId: string,
    chatMode: 'rag' | 'web',
    limit: number = 50,
    beforeTimestamp?: string 
  ): Promise<ChatMessageApp[]> => {
    console.warn("[chatMessageService.fetchMessages] This function might be deprecated or need adaptation for conversation-based chat. Currently fetches messages with NULL conversation_id.");
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return [];

    let query = supabase
      .from('chat_messages')
      .select('*')
      .eq('user_id', user.id)
      .eq('class_id', classId)
      .eq('chat_mode', chatMode)
      .is('conversation_id', null) 
      .order('created_at', { ascending: false })
      .limit(limit);
    
    if (beforeTimestamp) {
      query = query.lt('created_at', beforeTimestamp);
    }
    const { data, error } = await query;
    if (error) { console.error("Error in original fetchMessages:", error); throw error; }
    return (data || []).map(mapToAppMessage).reverse();
  },
};
