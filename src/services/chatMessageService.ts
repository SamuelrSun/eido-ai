// src/services/chatMessageService.ts
import { supabase } from "@/integrations/supabase/client";
import type { CustomDatabase } from "@/integrations/supabase/client";
import { FileType } from "@/features/files/types";

// --- TYPE DEFINITIONS (DEFINED AND EXPORTED HERE) ---

export type ChatMessageDBInsert = CustomDatabase['public']['Tables']['chat_messages']['Insert'];

/**
 * The rich source object used by the frontend. It's generated by the AI function
 * and reconstructed from the database when fetching message history.
 */
export interface ActiveSource {
  number: number;
  file: FileType;
  pageNumber: number | null;  
  content: string;
  file_id: string; // The foreign key used for saving
}

/**
 * The main chat message object used by the application UI.
 */
export interface ChatMessageApp {
  id: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  createdAt: Date;
  conversation_id: string;
  sources?: ActiveSource[];
  attached_files?: { name: string, type: string }[];
}

// --- MAIN SERVICE LOGIC ---

export const chatMessageService = {
  /**
   * Saves a message and its associated sources to the database.
   * This version ensures that if saving sources fails, the entire operation is rolled back.
   */
  saveMessage: async (
    messagePayload: Omit<ChatMessageDBInsert, 'user_id' | 'id' | 'created_at'> & { conversation_id: string; sources?: ActiveSource[] }
  ): Promise<ChatMessageApp> => {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) {
      throw new Error("User must be authenticated to save messages.");
    }

    // First, separate the sources from the core message data
    const { sources, ...coreMessageData } = messagePayload;
    const messageToSave: ChatMessageDBInsert = { ...coreMessageData, user_id: user.id };
    
    // Step 1: Save the core message text
    const { data: savedMessage, error: messageError } = await supabase
      .from('chat_messages')
      .insert(messageToSave)
      .select()
      .single();

    if (messageError) {
      console.error("Error saving core message:", messageError);
      throw messageError;
    }

    // Step 2: If there are sources, attempt to save them.
    let finalSourcesForApp: ActiveSource[] = [];
    if (sources && sources.length > 0) {
      const sourcesToInsert = sources.map(source => ({
        message_id: savedMessage.id,
        file_id: source.file_id,
        source_number: source.number,
        name: source.file.name,
        url: source.file.url,
        page_number: source.pageNumber,
        content: source.content,
      }));

      // Attempt to insert the sources
      const { error: sourcesError } = await supabase
        .from('message_sources')
        .insert(sourcesToInsert);

      // THIS IS THE CRITICAL FIX: If the insert fails, we must handle it.
      if (sourcesError) {
        console.error("Error saving sources, rolling back message:", sourcesError);
        
        // As a cleanup, attempt to delete the message we just created to avoid orphaned data.
        await supabase.from('chat_messages').delete().eq('id', savedMessage.id);
        
        // Most importantly, THROW the error so the UI knows the entire operation failed.
        throw sourcesError;
      }
      
      // Only assign the sources if the database insert was successful.
      finalSourcesForApp = sources;
    }

    // Step 3: Return the complete, successfully saved message object.
    return {
      id: savedMessage.id,
      role: savedMessage.role as 'user' | 'assistant' | 'system',
      content: savedMessage.content,
      createdAt: new Date(savedMessage.created_at),
      conversation_id: savedMessage.conversation_id!,
      attached_files: (savedMessage.attached_files as any) || [],
      sources: finalSourcesForApp,
    };
  },


  fetchMessagesByConversation: async (conversationId: string): Promise<ChatMessageApp[]> => {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user || !conversationId) return [];

    // Step 1: Fetch messages and perform a nested join to get their sources AND the full file data for each source.
    const { data: dbData, error } = await supabase
      .from('chat_messages')
      .select(`
        *,
        message_sources (
          *,
          files (*)
        )
      `)
      .eq('user_id', user.id)
      .eq('conversation_id', conversationId)
      .order('created_at', { ascending: true });

    if (error) {
      console.error("Error fetching messages with sources:", error);
      throw error;
    }
    
    // Step 2: Map the raw database result to the 'ChatMessageApp' type our frontend expects.
    return (dbData || []).map((dbRow): ChatMessageApp => {
      const message: ChatMessageApp = {
        id: dbRow.id,
        role: dbRow.role as 'user' | 'assistant' | 'system',
        content: dbRow.content,
        createdAt: new Date(dbRow.created_at),
        conversation_id: dbRow.conversation_id!,
        attached_files: (dbRow.attached_files as any) || [],
        sources: [],
      };

      // Step 3: If sources were returned from the join, reconstruct the 'sources' array.
      if (Array.isArray(dbRow.message_sources) && dbRow.message_sources.length > 0) {
        message.sources = dbRow.message_sources
          .filter(source => source.files) // Safety check: only include sources where the linked file exists.
          .map((source): ActiveSource => ({
            number: source.source_number,
            pageNumber: source.page_number,
            content: source.content,
            file_id: source.file_id,
            file: source.files as FileType, // The 'files(*)' join gives us the full FileType object.
        })).sort((a, b) => a.number - b.number); // Ensure sources are in the correct order.
      }
      
      return message;
    });
  },
};